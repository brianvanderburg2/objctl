#!/usr/bin/env python
#
# File:     pyifupdown
# Author:   Brian Allen Vanderburg II
# Purpose:  This script provides an ifupdown-like system for bringing network
#           interfaces up and down.  The bulk of the actual work is performed
#           by shell scripts in their respective hook directories.


# Imports
################################################################################

import sys
import os
import re
import stat
import subprocess
import argparse
import fnmatch
from collections import OrderedDict


# Globals
################################################################################

root_dir = "/etc/pynetwork"
script_dir = "scripts"
state_file = "run/state"
config_file = "interfaces"
cmdline = None

# Utility classes and functions
################################################################################

class Error(Exception):
    """ Base error class """
    pass

def message(msg):
    """ Displace a message to stderr. """
    sys.stderr.write(msg + '\n')
    sys.stderr.flush()

def run(command, env={}, show=None):
    """ Run a command with an environment. """
    # If command is a tuple/list, first is command, second is env
    if isinstance(command, (list, tuple)):
        env = mergedict(env, command[1])
        command = command[0]

    if cmdline.verbose:
        message(show if show else command)
    if cmdline.dumpenv:
        message(str(env))
        
    # return TRUE if command exits successfully or if we are forced
    # return FALSE only if command exits with failure and we are not forced
    p = subprocess.Popen(args=command, env=env, shell=True)
    return (p.wait() == 0) or cmdline.force

def runparts(path, env={}, reverse=False):
    """ Run all files in a directory with an environment. """
    basename = os.path.basename(path)
    parts = sorted(os.listdir(path), reverse=reverse)
    curdir = os.getcwd()
    for i in parts:
        filename = os.path.join(path, i)
        st = os.stat(filename)
        if st.st_mode & stat.S_IFREG and st.st_mode & stat.S_IXUSR:
            try:
                # Change directory to the location of the script
                os.chdir(os.path.dirname(os.path.realpath(filename)))
                status = run(filename, env, os.path.join(basename, i))
            finally:
                # Change back
                os.chdir(curdir)

            if status is False:
                return False

    return True

def makeenv(name, value):
    """ Make an environment variable from a configuration name. """
    name = name.replace('-', '_').upper()
    if type(value) in (list,tuple):
        value = ' '.join(value)

    return (name, value)

def mergedict(*args):
    """ Merge multiple dictionaries. """
    result = {}
    for i in args:
        result.update(i)
    return result


# Parser related code
################################################################################

class ParserLine(object):
    """ This class represents a line from the confiugration file. """
    def __init__(self, level, content, filename, lineno):
        self._level = level
        self._content = content
        self._words = None
        self._filename = filename
        self._lineno = lineno
        self._sublines = []

    @property
    def level(self):
        return self._level

    @property
    def content(self):
        return self._content

    @property
    def words(self):
        if self._words is None:
            self._words = self._parse()
        return self._words

    @property
    def filename(self):
        return self._filename

    @property
    def lineno(self):
        return self._lineno

    @property
    def position(self):
        return self._filename + ':' + str(self._lineno)

    @property
    def sublines(self):
        return tuple(self._sublines)

    def _parse(self):
        words = []
        word = ''

        quoted = False
        escaped = False
        addempty = False
        for i in self._content:
            # Handle escape characters
            if escaped:
                if not i in ('\\', '\"'):
                    raise Error('Invalid escape character: ' + self.position)

                word += i
                escaped = False
                continue

            # Add word at space
            if not quoted and i in (' ', '\t', '\r'):
                if len(word) > 0 or addempty:
                    words.append(word)
                    addempty = False
                word = ''
                continue

            if i == '\"':
                quoted = not quoted
                # When quoting, allow adding empty words
                addempty = True
                continue

            if i == '\\' and quoted:
                escaped = True
                continue

            word += i

        if len(word) > 0:
            words.append(word)
        
        if escaped:
            raise Error('Unterminated escape: ' + self.position)

        if quoted:
            raise Error('Unterminated quote: ' + self.position)

        return tuple(words)


class ParserSegment(object):
    """ This class represents a single open configuration file. """
    def __init__(self, filename, stack, offset=0, incfrom=None):
        self._filename = filename
        self._handle = None
        self._lineno = 0
        self._levels = []
        self._stack = stack
        self._offset = offset
        self._incfrom = incfrom

    def _nextline(self):
        if self._handle is None:
            if self._filename in self._stack:
                raise Error("Recursive source: " + self._incfrom)

            self._handle = open(self._filename, "rU")
            self._stack.append(self._filename)

        result = self._handle.readline()
        if len(result) == 0:
            return False

        self._lineno += 1
        if result[-1:] == '\n':
            result = result[:-1]

        return result
        
    def _calcline(self, line, lineno):
        pos = 0
        for i in line:
            if i == ' ':
                pos += 1
            elif i == '\t':
                pos = pos + 8 - (pos % 8)
            else:
                break

        if len(self._levels) == 0:
            # The first data line defines the level 0 indentation
            self._levels.append(pos)
        elif pos > self._levels[-1]:
            self._levels.append(pos)
        elif pos in self._levels:
            index = self._levels.index(pos)
            self._levels = self._levels[:index + 1]
        else:
            raise Error("Invalid indentation: " + self._filename + ":" + str(lineno))

        return ParserLine(len(self._levels) + self._offset - 1, line.strip(), self._filename, lineno)

    def readline(self):
        while True:
            # Read each line of multi-line, remember first line number
            line = ''
            part = self._nextline()
            lineno = self._lineno

            while not part is False:
                if part[-1:] == '\\':
                    if len(line) > 0:
                        line += ' '

                    line += part[:-1]
                    part = self._nextline()
                else:
                    line += part
                    break

            # If empty line and end of file
            if len(line) == 0 and part is False:
                return False

            # If blank line
            if len(line.strip()) == 0:
                continue

            # If a comment
            if line.strip()[0:1] == '#':
                continue

            # Otherwise, handle it and return
            return self._calcline(line, lineno)

    def close(self):
        if not self._handle is None:
            self._handle.close()
            self._stack.remove(self._filename)


class Parser(object):
    """ This class opens the configuration file and handles includes and conditinals. """
    def __init__(self, filename):
        self._stack = [] # Used to avoid recursion
        self._unread = []
        self._segments = []
        self._segments.append(ParserSegment(filename, self._stack))

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.close()

    def __iter__(self):
        line = self.readline()
        while not line is False:
            yield line
            line = self.readline()

    def close(self):
        for i in self._segments:
            i.close()
        self._segments = []

    def readline(self):
        # Check our unread first
        if len(self._unread) > 0:
            return self._unread.pop()

        while True:
            # While file are we reading from
            if len(self._segments) == 0:
                return False

            segment = self._segments[-1]
            line = segment.readline()

            # If nothing was read, close the current segment
            if line is False:
                segment.close()
                self._segments.pop()
                continue
            
            # Handle two-part special items
            words = line.words

            # If it is an inclusion, open new file or directory
            if len(words) > 0 and words[0] == 'include':
                if len(words) > 1:
                    filename = os.path.join(os.path.dirname(line.filename), words[1].replace('/', os.sep))

                    if os.path.isfile(filename):
                        self._segments.append(ParserSegment(filename, self._stack, line.level, line.position))
                    elif os.path.isdir(filename):
                        for i in reversed(sorted(os.listdir(filename))):
                            if i[:1] == '.' or i[-1:] == '~':
                                continue

                            subname = os.path.join(filename, i)
                            if os.path.isfile(subname):
                                self._segments.append(ParserSegment(subname, self._stack, line.level, line.position))
                    else:
                        raise Error("Referenced file not found: " + line.position)

                    continue
                else:
                    raise Error("No filename specified: " + line.position)

            # If anything else, it is a line to return
            return line

    def unread(self, line):
        self._unread.append(line)

    def read(self):
        """ Read all lines and then build the sublines lists """
        top = []
        state = [top]

        line = self.readline()
        while not line is False:
            if line.level == len(state):
                state.append(state[-1][-1]._sublines)
            elif line.level < len(state) - 1:
                state = state[:line.level + 1]
            elif line.level > len(state):
                raise Error('Unknown parse error')

            state[-1].append(line)
            line = self.readline()

        return top


# State management
################################################################################

class State(object):
    """ This object represents the current state of the devices. """

    def __init__(self, filename):
        """ Load the current state """
        self.filename = filename
        self.state = OrderedDict()

        if os.path.isfile(filename):
            with open(filename, 'rU') as handle:
                for line in handle:
                    parts = line.strip().split('=')
                    if len(parts) == 2:
                        self.state[parts[0].strip()] = parts[1].strip()

    def save(self):
        """ Save the state file. """
        dirname = os.path.dirname(self.filename)
        if not os.path.isdir(dirname):
            os.makedirs(dirname)
        with open(self.filename, 'wt') as handle:
            for i in self.state:
                handle.write('{0}={1}\n'.format(i, self.state[i]))

    def set(self, device, alias):
        self.state[device] = alias

    def remove(self, device):
        self.state.pop(device, None)

    def get(self, device):
        return self.state.get(device, None)

    def items(self):
        return list(self.state.keys())


# Configuration file objects
################################################################################

class IUpDown(object):
    """ Base class for objects that can be brought up and down. """
    def putup(self, processor, name):
        raise NotImplementedError

    def putdown(self, processor, name):
        raise NotImplementedError


class Iface(IUpDown):
    """ A class that represents the interface. """

    def __init__(self, config, line):
        """ Load the interface information. """
        self.preup = []
        self.up = []
        self.postup = []
        self.predown = []
        self.down = []
        self.postdown = []

        self.iface_env = None
        self.protos_env = []
        self.proto_types_env = []

        words = line.words

        # Read name 
        if len(words) > 1:
            self.name = words[1]
        else:
            raise Error('Expected name: ' + line.position)

        # Read other stuff
        upmap = { 'pre-up': self.preup, 'up': self.up, 'post-up': self.postup }
        downmap = { 'pre-down': self.predown, 'down': self.down, 'post-down': self.postdown }

        for i in line.sublines:
            words = i.words

            if words[0] == 'type':
                if self.iface_env:
                    raise Error('Only one type can be specified per interface: ' + i.position)
                self.readType(i)

            elif words[0] == 'proto':
                self.readProto(i)

            # Each up section is executed top to bottom
            elif words[0] in upmap:
                target = upmap[words[0]]
                for j in i.sublines:
                    target.append(j.content)

            # Each down section is executed bottom to top, but
            # the lines in each section are still executed in order
            elif words[0] in downmap:
                target = downmap[words[0]]
                for j in reversed(i.sublines):
                    target.insert(0, j.content)

            elif words[0] == 'call':
                config.call(i, self.preup, self.up, self.postup, self.predown, self.down, self.postdown)

            else:
                raise Error('Unexpected line: ' + i.position)

        # Enumerate protocol types
        self.buildProtoTypesEnv()

    def readType(self, line):
        """ Read type information """
        words = line.words

        # Read type name
        if len(words) > 1:
            type = words[1]
        else:
            raise Error('Expected type name: ' + line.position)

        # Read options
        opts = {}
        for i in line.sublines:
            words = i.words
            if len(words) > 1:
                opts[words[0]] = words[1:]
            else:
                raise Error('Exception option and value: ' + i.position)

        opts['TYPE'] = type

        # Build env
        env = {}
        for i in opts:
            (name, value) = makeenv(i, opts[i])
            env['IFACE_' + name] = value

        self.iface_env = env

    def readProto(self, line):
        """ Load the information. """
        words = line.words

        # Read section type and parameters
        if len(words) > 2:
            type = words[1]
            method = words[2]
        else:
            raise Error('Expected protocol and method: ' + line.position)

        # Read options
        opts = {}
        for i in line.sublines:
            words = i.words
            if len(words) > 1:
                opts[words[0]] = words[1:]
            else:
                raise Error('Exception option and value: ' + i.position)
        
        opts['TYPE'] = type
        opts['METHOD'] = method

        # Build env
        env = {}
        for i in opts:
            (name, value) = makeenv(i, opts[i])
            env['PROTO_' + name] = value

        self.protos_env.append(env)
    
    def buildProtoTypesEnv(self):
        """ Build the list of protoco; types on this interface """
        handled = []
        self.proto_types_env = []

        for i in self.protos_env:
            proto = i['PROTO_TYPE']
            if not proto in handled:
                handled.append(proto)
                (name, value) = makeenv('TYPE', proto)
                self.proto_types_env.append({'PROTO_' + name: value})

    def putup(self, processor, iface):
        """ Bring an object up. """
        env = {'IFACE': iface,
               'LOGICAL': self.name,
               'MODE': 'start',
               'PHASE': '',
               'PATH': os.environ['PATH'],
               'VERBOSE': '1' if cmdline.verbose else '0'}

        message('configuring interface {0}={1}'.format(iface, self.name))

        # Determine directories
        iface_preup_dir = os.path.join(script_dir, 'iface-pre-up.d')
        iface_up_dir = os.path.join(script_dir, 'iface-up.d')
        iface_postup_dir = os.path.join(script_dir, 'iface-post-up.d')
        proto_preup_dir = os.path.join(script_dir, 'proto-pre-up.d')
        proto_up_dir = os.path.join(script_dir, 'proto-up.d')
        proto_postup_dir = os.path.join(script_dir, 'proto-post-up.d')

        # pre-up
        if cmdline.verbose:
            message('interface pre-up')

        env['PHASE'] = 'pre-up'

        if self.iface_env:
            status = runparts(iface_preup_dir, mergedict(env, self.iface_env))
            if status is False:
                return False
        
        for i in self.proto_types_env:
            status = runparts(proto_preup_dir, mergedict(env, i))
            if status is False:
                return False

        for i in self.preup:
            status = run(i, env)
            if status is False:
                return False

        # up
        if cmdline.verbose:
            message('interface up')

        env['PHASE'] = 'up'

        if self.iface_env:
            status = runparts(iface_up_dir, mergedict(env, self.iface_env))
            if status is False:
                return False

        for i in self.protos_env:
            status = runparts(proto_up_dir, mergedict(env, i))
            if status is False:
                return False

        for i in self.up:
            status = run(i, env)
            if status is False:
                return False

        # post-up
        if cmdline.verbose:
            message('interface post-up')

        env['PHASE'] = 'post-up'
        
        if self.iface_env:
            status = runparts(iface_postup_dir, mergedict(env, self.iface_env))
            if status is False:
                return False
        
        for i in self.proto_types_env:
            status = runparts(proto_postup_dir, mergedict(env, i))
            if status is False:
                return False

        for i in self.postup:
            status = run(i, env)
            if status is False:
                return False

        return True
    
    def putdown(self, processor, iface):
        """ Bring an interface down. """
        env = {'IFACE': iface,
               'LOGICAL': self.name,
               'MODE': 'stop',
               'PHASE': '',
               'PATH': os.environ['PATH'],
               'VERBOSE': '1' if cmdline.verbose else '0'}

        message('deconfiguring interface {0}={1}'.format(iface, self.name))
        
        # Determine directories
        iface_predown_dir = os.path.join(script_dir, 'iface-pre-down.d')
        iface_down_dir = os.path.join(script_dir, 'iface-down.d')
        iface_postdown_dir = os.path.join(script_dir, 'iface-post-down.d')
        proto_predown_dir = os.path.join(script_dir, 'proto-pre-down.d')
        proto_down_dir = os.path.join(script_dir, 'proto-down.d')
        proto_postdown_dir = os.path.join(script_dir, 'proto-post-down.d')

        # pre-down
        if cmdline.verbose:
            message('interface pre-down')

        env['PHASE'] = 'pre-down'

        for i in self.predown:
            status = run(i, env)
            if status is False:
                return False
        
        for i in reversed(self.proto_types_env):
            status = runparts(proto_predown_dir, mergedict(env, i), True)
            if status is False:
                return False

        if self.iface_env:
            status = runparts(iface_predown_dir, mergedict(env, self.iface_env), True)
            if status is False:
                return False

        # down
        if cmdline.verbose:
            message('interface down')

        env['PHASE'] = 'down'

        for i in self.down:
            status = run(i, env)
            if status is False:
                return False
        
        for i in reversed(self.protos_env):
            status = runparts(proto_down_dir, mergedict(env, i), True)
            if status is False:
                return False

        if self.iface_env:
            status = runparts(iface_down_dir, mergedict(env, self.iface_env), True)
            if status is False:
                return False

        # post-down
        if cmdline.verbose:
            message('interface post-down')

        env['PHASE'] = 'post-down'
        
        for i in self.postdown:
            status = run(i, env)
            if status is False:
                return False
        
        for i in reversed(self.proto_types_env):
            status = runparts(proto_postdown_dir, mergedict(env, i), True)
            if status is False:
                return False

        if self.iface_env:
            status = runparts(iface_postdown_dir, mergedict(env, self.iface_env), True)
            if status is False:
                return False

        return True

class Group(IUpDown):
    """ A class that represents a group of interfaces. """

    def __init__(self, config, line):
        """ Load the group information. """
        self.preup = []
        self.postup = []
        self.predown = []
        self.postdown = []

        words = line.words

        # Read name and dependenices
        if len(words) > 1:
            self.name = words[1]
            if len(words) > 2:
                self.dependencies = words[2:]
            else:
                self.dependencies = []
        else:
            raise Error('Expected name and optional dependencies: ' + line.position)

        # Read other stuff
        upmap = { 'pre-up': self.preup, 'post-up': self.postup }
        downmap = { 'pre-down': self.predown, 'post-down': self.postdown }

        for i in line.sublines:
            words = i.words

            # Each up section is executed top to bottom
            if words[0] in upmap:
                target = upmap[words[0]]
                for j in i.sublines:
                    target.append(j.content)

            # Each down section is executed bottom to top, but
            # the lines in each section are still executed in order
            elif words[0] in downmap:
                target = downmap[words[0]]
                for j in reversed(i.sublines):
                    target.insert(0, j.content)

            elif words[0] == 'call':
                config.call(i, self.preup, None, self.postup, self.predown, None, self.postdown)

            else:
                raise Error('Unexpected line: ' + i.position)


    def putup(self, processor, group):
        """ Bring a group up. """
        env = {'GROUP': group,
               'LOGICAL': self.name,
               'MODE': 'start',
               'PHASE': '',
               'PATH': os.environ['PATH'],
               'VERBOSE': '1' if cmdline.verbose else '0'}

        message('configuring group {0}={1}'.format(group, self.name))

        # pre-up
        if cmdline.verbose:
            message('group pre-up')

        env['PHASE'] = 'pre-up'
        for i in self.preup:
            status = run(i, env)
            if status is False:
                return False

        # up
        for i in self.dependencies:
            status = processor.putup(i)
            if status is False:
                return False

        # post-up
        if cmdline.verbose:
            message('group post-up')

        env['PHASE'] = 'post-up'
        for i in self.postup:
            status = run(i, env)
            if status is False:
                return False

        return True
    
    def putdown(self, processor, group):
        """ Bring an group down. """
        env = {'GROUP': group,
               'LOGICAL': self.name,
               'MODE': 'stop',
               'PHASE': '',
               'PATH': os.environ['PATH'],
               'VERBOSE': '1' if cmdline.verbose else '0'}

        message('deconfiguring group {0}={1}'.format(group, self.name))

        # pre-down
        if cmdline.verbose:
            message('group pre-down')

        env['PHASE'] = 'pre-down'
        for i in self.predown:
            status = run(i, env)
            if status is False:
                return False

        # down
        for i in reversed(self.dependencies):
            status = processor.putdown(i)
            if status is False:
                return False

        # post-down
        if cmdline.verbose:
            message('group post-down')

        env['PHASE'] = 'post-down'
        for i in self.postdown:
            status = run(i, env)
            if status is False:
                return False

        return True


class Define(object):
    """ A define is a reusable set of pre/post commands. """

    def __init__(self, line):
        """ Load the commands. """
        self.preup = []
        self.up = []
        self.postup = []
        self.predown = []
        self.down = []
        self.postdown = []

        words = line.words

        # Read name
        if len(words) > 1:
            self.name = words[1]

        # Read lines
        linemap = {
            'pre-up': self.preup, 'up': self.up, 'post-up': self.postup,
            'pre-down': self.predown, 'down': self.down, 'post-down': self.postdown
        }

        for i in line.sublines:
            words = i.words

            # We remember all the lines in order here, then
            # reverse the ones needed when inserting them into
            # the interface/group up/down commands
            if words[0] in linemap:
                target = linemap[words[0]]
                if len(target) > 0:
                    raise Error('A ' + words[0] + ' section should only be specfied once in define: ' + i.position)
                else:
                    for j in i.sublines:
                        target.append(j.content)

            else:
                raise Error('Unexpected line: ' + i.position)

    def evaluate(self, line, preup, up, postup, predown, down, postdown):
        """ Evaluate the defines and merge into the lists """
        # Build the environment
        env = {}
        for i in line.words[2:]:
            parts = i.split('=')
            if len(parts) > 1:
                (name, value) = makeenv(parts[0], parts[1])
                env[name] = value

        # Insert the command lines
        upmap = ((self.preup, preup), (self.up, up), (self.postup, postup))
        downmap = ((self.predown, predown), (self.down, down), (self.postdown, postdown))

        # Each up section is executed top to bottom
        for (ours, theirs) in upmap:
            if not theirs is None:
                for i in ours:
                    theirs.append((i, env))

        # Each down section is executed bottom to top, but
        # the lines in each section are still executed in order
        for (ours, theirs) in downmap:
            if not theirs is None:
                for i in reversed(ours):
                    theirs.insert(0, (i, env))

class Mapping(object):
    """ A mapping object. """
    def __init__(self, line):
        """ Read the mapping information """

        self.script = None
        self.lines = []

        words = line.words

        # Read the pattern
        if len(words) > 1:
            self.patterns = words[1:]
        else:
            raise Error('Mapping pattern expected: ' + line.position)

        # Read sublines
        for i in line.sublines:
            words = i.words

            if words[0] == 'script':
                if len(words) > 1:
                    if self.script is None:
                        self.script = words[1]
                    else:
                        raise Error('Script can only be specified once: ' + i.position)
                else:
                    raise Error('Script path expected: ' + i.position)

            elif words[0] == 'map':
                if len(words) > 0:
                    self.lines.append(' '.join(words[1:]))
                else:
                    raise Error('Unexpected end of line: ' + i.position)

            else:
                raise Error('Unexpected line: ' + i.position)

    def check(self, name):
        return any([fnmatch.fnmatch(name, i) for i in self.patterns])

    def resolve(self, name):
        """ Resolve the mapping to the logical interface. """
        # Start the process
        command = [self.script, name]
        env = { 'PATH': os.environ['PATH'] }
        ps = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, env=env)

        # Send input
        for i in self.lines:
            ps.stdin.write(i + '\n')
        ps.stdin.close()

        # Read the output
        retval = ps.wait()
        result = None
        for i in ps.stdout:
            result = i.strip()
            if len(result) == 0:
                result = None
            else:
                break
        ps.stdout.close()

        return result if retval == 0 else None


class Config(object):
    """ A class for the configuration file. """

    def __init__(self, filename):
        """ Read the configuration file. """
        self.updowns = OrderedDict()
        self.defines = {}
        self.mappings = []
        self.allows = {}

        p = Parser(filename)
        lines = p.read()

        for i in lines:
            words = i.words

            if words[0] == 'allow':
                if len(words) > 2:
                    if not words[1] in self.allows:
                        self.allows[words[1]] = []
                    if not words[2] in self.allows[words[1]]:
                        self.allows[words[1]].append(words[2])
                else:
                    raise Error('Expected name and object: ' + i.position)

            elif words[0] == 'iface' or words[0] == 'interface':
                iface = Iface(self, i)
                if iface.name in self.updowns:
                    raise Error('Interface or group name already specified: ' + i.position)
                else:
                    self.updowns[iface.name] = iface

            elif words[0] == 'group':
                group = Group(self, i)
                if group.name in self.updowns:
                    raise Error('Interface or group name already specified: ' + i.position)
                else:
                    self.updowns[group.name] = group

            elif words[0] == 'define':
                define = Define(i)
                if define.name in self.defines:
                    raise Error('Define name already specified: ' + i.position)
                else:
                    self.defines[define.name] = define

            elif words[0] == 'mapping':
                mapping = Mapping(i)
                self.mappings.append(mapping)

            else:
                raise Error('Unexpected line: ' + i.position)

    def call(self, line, preup, up, postup, predown, down, postdown):
        """ Call a define. """
        words = line.words
        if len(words) > 1:
            name = words[1]
            if name in self.defines:
                self.defines[name].evaluate(line, preup, up, postup, predown, down, postdown)
            else:
                raise Error('Unknown define called: ' + line.position)
        else:
            raise Error('Define name not specified: ' + line.position)



# Processor to manage things.
################################################################################

class Processor(object):
    """ The processor object. """

    def __init__(self):
        """ Load the current config and state. """
        self.config = Config(config_file)
        self.state = State(state_file)

    def find(self, name, mappings=True):
        """ Apply mappings if needed to find the name and logical. """
        parts = name.split('=')
        if len(parts) == 2:
            return (parts[0], parts[1])

        if mappings:
            for i in self.config.mappings:
                if i.check(name):
                    return (parts[0], i.resolve(name))

        return (parts[0], parts[0])

    def allowed(self, names, allow):
        """ Determine allowed interfaces. """
        if not allow and not names:
            # Return false to indicate no items passed
            # This has a different meaning from retuning an empty list to
            # incate that the intersection of allow and names was empty
            return False

        # NOTE: When using an allow from the command line, you can not specify
        # a logical interfaces: "-a auto eth0" is okay, but "-a auto etho0=home"
        # is not okay
        if allow:
            # An allow has been specified, so update names as needed
            # The returned list should be in the same order as the
            # allows specified in the configuration
            if allow in self.config.allows:
                if len(names) == 0:
                    return list(self.config.allows[allow])
                else:
                    return [i for i in self.config.allows[allow] if i in names]
            else:
                message('allow {0} not found'.format(allow))
                return []
        else:
            # You can specify logical interfaces when not using an allow
            # "eth0=home" is okay, as long as not specifying an allow
            return names

    def putup(self, name):
        """ Bring up an interface/group """
        (name, logical) = self.find(name)

        # Check if already up
        current = self.state.get(name)
        if not current is None:
            message('interface/group {0} already configured as {1}'.format(name, current))
            if cmdline.force:
                message('configuration forced')
            else:
                return False
        
        # Check if mapping is found
        if logical is None:
            message('interface/group {0} mapping unresolved'.format(name))
            return cmdline.force

        # Check that definition exists
        if not logical in self.config.updowns:
            message('interface/group {0}={1} unknown'.format(name, logical))
            return cmdline.force

        # Put it up
        status = self.config.updowns[logical].putup(self, name)
        if status is False:
            # Failed to bring it up and not forced.  Instead of leaving it in
            # unstable state, try to bring it back down
            message('failed to configure {0}={1}'.format(name, logical))
            self.config.updowns[logical].putdown(self, name)
            return False
        else:
            self.state.set(name, logical)

        return True

    def putdown(self, name):
        """ Bring down an interface/group. """
        (name, logical) = self.find(name)

        # Make sure it is already up
        curlogical = self.state.get(name)
        if curlogical is None:
            message('interface/group {0} not configured'.format(name))
            if cmdline.force:
                curlogical=logical
                message('configuration forced')
            else:
                return False

        # Check that definition exists
        if not curlogical in self.config.updowns:
            message('interface/group {0}={1} unknown'.format(name, curlogical))
            return cmdline.force

        # Put it down
        status = self.config.updowns[curlogical].putdown(self, name)
        if status is False:
            message('failed to deconfigure {0}={1}'.format(name, logical))
            return False
        else:
            self.state.remove(name)

        return True

    def cmdup(self, names, allow):
        """ Bring up interfaces/groups from the command line. """
        names = self.allowed(names, allow)
        if names is False:
            raise Error('Nothing to put up')

        for i in names:
            status = self.putup(i)
            if status is False:
                return False

        return True
    
    def cmddown(self, names, allow):
        """ Bring down interfaces/groups from the command line. """
        names = self.allowed(names, allow)
        if names is False:
            raise Error('Nothing to bring down')

        for i in reversed(names):
            status = self.putdown(i)
            if status is False:
                return False

        return True

    def cmdshutdown(self):
        """ Shut down all current interfaces. """
        # We put down the interfaces backwards.  We need to check
        # the last item each time, because if we are putting down
        # a group, it may put down other interfaces for us.
        items = self.state.items()
        while len(items) > 0:
            name = items[-1]
            status = self.putdown(name)
            if status is False:
                return False
            items = self.state.items()

        return True

    def cmdlist(self, names, allow):
        """ List all known stanzas """
        names = self.allowed(names, allow)
        if names is False:
            names = self.config.updowns.keys()

        for i in names:
            print(i)

        return True

    def cmdquery(self, names, allow):
        """ Query the current state of interfaecs. """
        names = self.allowed(names, allow)
        items = self.state.items()
        for i in items:
            if names is False or i in names:
                logical = self.state.get(i)
                if not logical is None:
                    print('{0}={1}'.format(i, logical))
        return True

    def save(self):
        """ Save information before quitting. """
        self.state.save()


# Main program entry
################################################################################

def main():
    # Globals affected
    global cmdline
    global root_dir
    global script_dir
    global state_file
    global config_file

    # Parse the command line
    parser = argparse.ArgumentParser(description='Simple python network interface control script')
    parser.add_argument('-a', '--allow', dest='allow', action='store', required=False, help='Allow only interfaces and groups that match to be affected.')
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', required=False, default=False, help='Show verbose details.')
    parser.add_argument('-e', '--show-env', dest='dumpenv', action='store_true', required=False, default=False, help='Dump environment variables for each executed command.')
    parser.add_argument('-f', '--force', dest='force', action='store_true', required=False, default=False, help='Force interface configuration or deconfiguration.')
    group = parser.add_argument_group('files')
    group.add_argument('-r', '--root', dest='root_dir', action='store', default=root_dir, help='Specify a root for all configuration-related files.')
    group.add_argument('-s', '--state', dest='state_file', action='store', default=state_file, help='Specify a different state file.')
    group.add_argument('-i', '--interfaces', dest='config_file', action='store', default=config_file, help='Specify a different interfaces file.')
    group.add_argument('-d', '--scripts', dest='script_dir', action='store', default=script_dir, help='Specify a different hook script directory.')

    parser.add_argument('action', action='store', choices=['up', 'down', 'shutdown', 'list', 'query'], help='Action to perform with specified interfaces and groups.')
    parser.add_argument('targets', action='store', nargs='*', help='Interfaces and groups to affect')

    cmdline = parser.parse_args()

    # Update the globals
    if not os.path.isdir(cmdline.root_dir):
        raise Error('directory {0} does not exist'.format(cmdline.root_dir))

    script_dir = os.path.realpath(os.path.join(cmdline.root_dir, cmdline.script_dir))
    state_file = os.path.realpath(os.path.join(cmdline.root_dir, cmdline.state_file))
    config_file = os.path.realpath(os.path.join(cmdline.root_dir, cmdline.config_file))

    # Create the processor and execute the actions
    proc = Processor()
    if cmdline.action == 'up':
        status = proc.cmdup(cmdline.targets, cmdline.allow)
    elif cmdline.action == 'down':
        status = proc.cmddown(cmdline.targets, cmdline.allow)
    elif cmdline.action == 'shutdown':
        status = proc.cmdshutdown()
    elif cmdline.action == 'list':
        status = proc.cmdlist(cmdline.targets, cmdline.allow)
    elif cmdline.action == 'query':
        status = proc.cmdquery(cmdline.targets, cmdline.allow)
    else:
        raise Error("action '" + cmdline.action + "' not implemented.")

    proc.save()
    return status


# Run it
if __name__ == '__main__':
    try:
        status = main()
        sys.exit(0 if status is True else -1)
    except (Error, IOError, OSError) as e:
        message('{0}: {1}'.format(type(e).__name__, str(e)))
        sys.exit(-1)
